{"version":3,"file":"common.js","sourceRoot":"","sources":["../../src/plugins/common.ts"],"names":[],"mappings":"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","sourcesContent":["import FormData = require('form-data')\r\nimport { stringify as stringifyQuery, parse as parseQuery } from 'querystring'\r\nimport isHostObject from './is-host/index'\r\nimport { Request } from '../request'\r\nimport { Response } from '../response'\r\nimport form from '../form'\r\n\r\nconst JSON_MIME_REGEXP = /^application\\/(?:[\\w!#\\$%&\\*`\\-\\.\\^~]*\\+)?json$/i\r\nconst URL_ENCODED_MIME_REGEXP = /^application\\/x-www-form-urlencoded$/i\r\nconst FORM_MIME_REGEXP = /^multipart\\/form-data$/i\r\n\r\nconst JSON_PROTECTION_PREFIX = /^\\)\\]\\}',?\\n/\r\n\r\n/**\r\n * Simply wrap a value and return it.\r\n */\r\nexport function wrap <T> (value: T): () => T {\r\n  return () => value\r\n}\r\n\r\n/**\r\n * Remove default headers.\r\n */\r\nexport const headers = wrap(function (request: Request, next: () => Promise<Response>) {\r\n  // If we have no accept header set already, default to accepting\r\n  // everything. This is needed because otherwise Firefox defaults to\r\n  // an accept header of `html/xml`.\r\n  if (!request.get('Accept')) {\r\n    request.set('Accept', '*/*')\r\n  }\r\n\r\n  // Remove headers that should never be set by the user.\r\n  request.remove('Host')\r\n\r\n  return next()\r\n})\r\n\r\n/**\r\n * Stringify the request body.\r\n */\r\nexport const stringify = wrap(function (request: Request, next: () => Promise<Response>) {\r\n  const { body } = request\r\n\r\n  // Convert primitives types into strings.\r\n  if (Object(body) !== body) {\r\n    request.body = body == null ? null : String(body)\r\n\r\n    return next()\r\n  }\r\n\r\n  if (isHostObject(body)) {\r\n    return next()\r\n  }\r\n\r\n  let type = request.type()\r\n\r\n  // Set the default mime type to be JSON if none exists.\r\n  if (!type) {\r\n    type = 'application/json'\r\n\r\n    request.type(type)\r\n  }\r\n\r\n  // Automatically stringify expected MIME types.\r\n  try {\r\n    if (JSON_MIME_REGEXP.test(type)) {\r\n      request.body = JSON.stringify(body)\r\n    } else if (FORM_MIME_REGEXP.test(type)) {\r\n      request.body = form(body)\r\n    } else if (URL_ENCODED_MIME_REGEXP.test(type)) {\r\n      request.body = stringifyQuery(body)\r\n    }\r\n  } catch (err) {\r\n    return Promise.reject(request.error('Unable to stringify request body: ' + err.message, 'ESTRINGIFY', err))\r\n  }\r\n\r\n  // Remove the `Content-Type` header from form data requests. Browsers\r\n  // will only fill it automatically with the boundary when it isn't set.\r\n  if (request.body instanceof FormData) {\r\n    request.remove('Content-Type')\r\n  }\r\n\r\n  return next()\r\n})\r\n\r\nexport type ParseType = 'json' | 'urlencoded'\r\n\r\n/**\r\n * Parse the response body.\r\n */\r\nexport function parse (type: ParseType | ParseType[], strict?: boolean) {\r\n  const types = Array.isArray(type) ? type : [type]\r\n\r\n  for (const type of types) {\r\n    if (type !== 'json' && type !== 'urlencoded') {\r\n      throw new TypeError(`Unexpected parse type: ${type}`)\r\n    }\r\n  }\r\n\r\n  return function (request: Request, next: () => Promise<Response>) {\r\n    return next()\r\n      .then(function (response) {\r\n        const { body } = response\r\n        const responseType = response.type()\r\n\r\n        // Empty bodies are _always_ `null`.\r\n        if (body == null || body === '') {\r\n          response.body = null\r\n          return response\r\n        }\r\n\r\n        // Throw on invalid response type.\r\n        if (responseType == null) {\r\n          throw request.error(`Unable to parse empty response content type`, 'EPARSE')\r\n        }\r\n\r\n        // Error on non-string bodies.\r\n        if (typeof body !== 'string') {\r\n          throw request.error(`Unable to parse non-string response body`, 'EPARSE')\r\n        }\r\n\r\n        // Attempt to parse as each type.\r\n        for (const type of types) {\r\n          if (type === 'json' && JSON_MIME_REGEXP.test(responseType)) {\r\n            try {\r\n              response.body = JSON.parse(body.replace(JSON_PROTECTION_PREFIX, ''))\r\n            } catch (err) {\r\n              throw request.error(`Unable to parse response body: ${err.message}`, 'EPARSE', err)\r\n            }\r\n\r\n            return response\r\n          }\r\n\r\n          if (type === 'urlencoded' && URL_ENCODED_MIME_REGEXP.test(responseType)) {\r\n            response.body = parseQuery(body)\r\n            return response\r\n          }\r\n        }\r\n\r\n        if (strict !== false) {\r\n          throw request.error(`Unhandled response type: ${responseType}`, 'EPARSE')\r\n        }\r\n\r\n        return response\r\n      })\r\n  }\r\n}\r\n"]}